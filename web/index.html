<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ALEPH Observer ‚Äî Neural Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      :root {
        --bg-void: #06060c;
        --bg-primary: #0a0a14;
        --bg-panel: rgba(14, 14, 26, 0.75);
        --bg-glass: rgba(20, 20, 40, 0.45);
        --border-glass: rgba(80, 80, 160, 0.2);
        --border-glow: rgba(0, 200, 255, 0.15);
        --accent-cyan: #00d4ff;
        --accent-magenta: #ff00aa;
        --accent-green: #00ff88;
        --accent-yellow: #ffd700;
        --accent-red: #ff3344;
        --accent-purple: #aa44ff;
        --accent-blue: #4488ff;
        --text-primary: #e8e8f0;
        --text-secondary: #7878a0;
        --text-dim: #4a4a6a;
        --glow-cyan: 0 0 20px rgba(0, 212, 255, 0.3);
        --glow-magenta: 0 0 20px rgba(255, 0, 170, 0.3);
      }

      * { margin: 0; padding: 0; box-sizing: border-box; }

      body {
        font-family: 'Inter', -apple-system, sans-serif;
        background: var(--bg-void);
        color: var(--text-primary);
        overflow-x: hidden;
        min-height: 100vh;
      }

      /* HEADER */
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 24px;
        background: linear-gradient(180deg, rgba(10,10,20,0.95) 0%, rgba(10,10,20,0) 100%);
        position: sticky;
        top: 0;
        z-index: 100;
        backdrop-filter: blur(12px);
      }

      .header-left {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .logo {
        font-size: 24px;
        font-weight: 700;
        background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: 4px;
      }

      .connection-badge {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 500;
        background: rgba(255,51,68,0.15);
        color: var(--accent-red);
        border: 1px solid rgba(255,51,68,0.3);
        transition: all 0.5s ease;
      }
      .connection-badge.connected {
        background: rgba(0,255,136,0.1);
        color: var(--accent-green);
        border-color: rgba(0,255,136,0.3);
      }
      .connection-dot {
        width: 6px; height: 6px;
        border-radius: 50%;
        background: currentColor;
        animation: pulse 2s infinite;
      }

      .header-stats {
        display: flex;
        gap: 20px;
        font-size: 12px;
        color: var(--text-secondary);
        font-family: 'JetBrains Mono', monospace;
      }
      .header-stats span { color: var(--accent-cyan); font-weight: 500; }

      /* TRAUMA ALERT BANNER */
      .trauma-banner {
        display: none;
        padding: 8px 24px;
        background: linear-gradient(90deg, rgba(255,51,68,0.15), rgba(255,0,170,0.1));
        border-bottom: 1px solid rgba(255,51,68,0.3);
        font-size: 13px;
        font-weight: 500;
        color: var(--accent-red);
        text-align: center;
        animation: traumaPulse 1.5s ease-in-out infinite;
      }
      .trauma-banner.active { display: block; }

      /* MAIN GRID */
      .dashboard {
        display: grid;
        grid-template-columns: 1fr 380px;
        grid-template-rows: auto auto;
        gap: 16px;
        padding: 16px 24px 24px;
        max-width: 1600px;
        margin: 0 auto;
      }

      /* GLASS PANEL */
      .panel {
        background: var(--bg-glass);
        border: 1px solid var(--border-glass);
        border-radius: 16px;
        backdrop-filter: blur(16px);
        overflow: hidden;
        transition: border-color 0.3s ease;
      }
      .panel:hover { border-color: var(--border-glow); }

      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 18px;
        border-bottom: 1px solid var(--border-glass);
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: var(--text-secondary);
      }
      .panel-header .icon { font-size: 14px; margin-right: 8px; }
      .panel-body { padding: 16px 18px; }

      /* 3D RESERVOIR */
      .reservoir-panel {
        grid-column: 1;
        grid-row: 1;
        min-height: 420px;
        position: relative;
      }
      #reservoir-canvas {
        width: 100%;
        height: 380px;
        border-radius: 0 0 16px 16px;
      }

      /* CHEMISTRY PANEL */
      .chemistry-panel {
        grid-column: 2;
        grid-row: 1;
      }

      .chem-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 14px;
      }
      .chem-label {
        font-size: 11px;
        font-weight: 500;
        color: var(--text-secondary);
        width: 80px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .chem-bar-track {
        flex: 1;
        height: 8px;
        background: rgba(255,255,255,0.04);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
      }
      .chem-bar-fill {
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease, background 0.3s ease;
        box-shadow: 0 0 12px rgba(0,0,0,0.5);
      }
      .chem-value {
        font-size: 12px;
        font-family: 'JetBrains Mono', monospace;
        font-weight: 500;
        width: 40px;
        text-align: right;
      }

      /* SPARKLINE */
      .sparkline-container {
        margin-top: 8px;
        padding-top: 14px;
        border-top: 1px solid var(--border-glass);
      }
      .sparkline-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
      }
      .sparkline-label {
        font-size: 10px;
        color: var(--text-dim);
        width: 65px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }
      .sparkline-canvas {
        height: 24px;
        flex: 1;
        border-radius: 4px;
        background: rgba(0,0,0,0.2);
      }

      /* CONSCIOUSNESS STREAM */
      .stream-panel {
        grid-column: 1;
        grid-row: 2;
      }
      .stream-content {
        max-height: 260px;
        overflow-y: auto;
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        line-height: 1.8;
        scrollbar-width: thin;
        scrollbar-color: var(--border-glass) transparent;
      }
      .stream-content::-webkit-scrollbar { width: 4px; }
      .stream-content::-webkit-scrollbar-thumb { background: var(--border-glass); border-radius: 4px; }
      .stream-entry {
        padding: 4px 0;
        border-bottom: 1px solid rgba(255,255,255,0.02);
        opacity: 0;
        animation: fadeIn 0.3s ease forwards;
      }
      .stream-entry.system { color: var(--accent-cyan); }
      .stream-entry.ego { color: var(--accent-magenta); }
      .stream-entry.voice { color: var(--accent-green); }

      /* CONTROLS PANEL */
      .controls-panel {
        grid-column: 2;
        grid-row: 2;
      }

      .control-buttons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 16px;
      }

      .btn {
        padding: 10px 16px;
        border: 1px solid var(--border-glass);
        border-radius: 10px;
        background: rgba(255,255,255,0.03);
        color: var(--text-primary);
        font-family: 'Inter', sans-serif;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.25s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }
      .btn:hover {
        background: rgba(255,255,255,0.08);
        border-color: var(--accent-cyan);
        box-shadow: var(--glow-cyan);
        transform: translateY(-1px);
      }
      .btn:active { transform: translateY(0); }
      .btn.danger:hover {
        border-color: var(--accent-red);
        box-shadow: 0 0 20px rgba(255,51,68,0.3);
      }

      .stimulus-input {
        display: flex;
        gap: 8px;
      }
      .stimulus-input input {
        flex: 1;
        padding: 10px 14px;
        border: 1px solid var(--border-glass);
        border-radius: 10px;
        background: rgba(0,0,0,0.3);
        color: var(--text-primary);
        font-family: 'Inter', sans-serif;
        font-size: 13px;
        outline: none;
        transition: border-color 0.3s;
      }
      .stimulus-input input:focus {
        border-color: var(--accent-cyan);
      }
      .stimulus-input input::placeholder {
        color: var(--text-dim);
      }

      /* SYSTEM STATS */
      .sys-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 16px;
        padding-top: 14px;
        border-top: 1px solid var(--border-glass);
      }
      .sys-stat {
        text-align: center;
        padding: 8px;
        border-radius: 8px;
        background: rgba(0,0,0,0.2);
      }
      .sys-stat-value {
        font-family: 'JetBrains Mono', monospace;
        font-size: 16px;
        font-weight: 600;
        color: var(--accent-cyan);
      }
      .sys-stat-label {
        font-size: 9px;
        color: var(--text-dim);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-top: 2px;
      }

      /* ANIMATIONS */
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(4px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes traumaPulse {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
      }

      /* RESPONSIVE */
      @media (max-width: 900px) {
        .dashboard {
          grid-template-columns: 1fr;
        }
        .reservoir-panel { grid-column: 1; grid-row: 1; }
        .chemistry-panel { grid-column: 1; grid-row: 2; }
        .stream-panel { grid-column: 1; grid-row: 3; }
        .controls-panel { grid-column: 1; grid-row: 4; }
      }
    </style>
  </head>
  <body>
    <!-- HEADER -->
    <header class="header">
      <div class="header-left">
        <div class="logo">ALEPH</div>
        <div class="connection-badge" id="conn-badge">
          <div class="connection-dot"></div>
          <span id="conn-text">DISCONNECTED</span>
        </div>
      </div>
      <div class="header-stats">
        <div>Hz: <span id="stat-hz">0</span></div>
        <div>Neurons: <span id="stat-neurons">0</span></div>
        <div>Entropy: <span id="stat-entropy">0.00</span></div>
        <div>Hebbian: <span id="stat-hebbian">0</span></div>
      </div>
    </header>

    <!-- TRAUMA ALERT -->
    <div class="trauma-banner" id="trauma-banner">
      üî• LUCIFER PROTOCOL ACTIVE ‚Äî Firefighter Mode Engaged ‚Äî Temperature Clamped
    </div>

    <!-- MAIN DASHBOARD -->
    <div class="dashboard">
      <!-- 3D RESERVOIR -->
      <div class="panel reservoir-panel">
        <div class="panel-header">
          <div><span class="icon">üß†</span> Neural Reservoir</div>
          <div id="reservoir-info" style="color: var(--accent-cyan);">Loading...</div>
        </div>
        <canvas id="reservoir-canvas"></canvas>
      </div>

      <!-- CHEMISTRY -->
      <div class="panel chemistry-panel">
        <div class="panel-header">
          <div><span class="icon">‚öóÔ∏è</span> Neurochemistry</div>
          <div id="chem-state" style="font-size:10px;">STABLE</div>
        </div>
        <div class="panel-body">
          <div class="chem-row">
            <div class="chem-label">Dopamine</div>
            <div class="chem-bar-track"><div class="chem-bar-fill" id="bar-dopamine" style="width:50%; background: linear-gradient(90deg, #ffd700, #ff8800);"></div></div>
            <div class="chem-value" id="val-dopamine" style="color: var(--accent-yellow);">0.50</div>
          </div>
          <div class="chem-row">
            <div class="chem-label">Cortisol</div>
            <div class="chem-bar-track"><div class="chem-bar-fill" id="bar-cortisol" style="width:0%; background: linear-gradient(90deg, #ff3344, #ff0066);"></div></div>
            <div class="chem-value" id="val-cortisol" style="color: var(--accent-red);">0.00</div>
          </div>
          <div class="chem-row">
            <div class="chem-label">Adenosine</div>
            <div class="chem-bar-track"><div class="chem-bar-fill" id="bar-adenosine" style="width:0%; background: linear-gradient(90deg, #4488ff, #2244cc);"></div></div>
            <div class="chem-value" id="val-adenosine" style="color: var(--accent-blue);">0.00</div>
          </div>
          <div class="chem-row">
            <div class="chem-label">Oxytocin</div>
            <div class="chem-bar-track"><div class="chem-bar-fill" id="bar-oxytocin" style="width:50%; background: linear-gradient(90deg, #ff00aa, #ff44cc);"></div></div>
            <div class="chem-value" id="val-oxytocin" style="color: var(--accent-magenta);">0.50</div>
          </div>
          <div class="chem-row">
            <div class="chem-label">Serotonin</div>
            <div class="chem-bar-track"><div class="chem-bar-fill" id="bar-serotonin" style="width:50%; background: linear-gradient(90deg, #00ff88, #00cc66);"></div></div>
            <div class="chem-value" id="val-serotonin" style="color: var(--accent-green);">0.50</div>
          </div>

          <!-- SPARKLINES -->
          <div class="sparkline-container">
            <div class="sparkline-row"><div class="sparkline-label">Dopamine</div><canvas class="sparkline-canvas" id="spark-dopamine"></canvas></div>
            <div class="sparkline-row"><div class="sparkline-label">Cortisol</div><canvas class="sparkline-canvas" id="spark-cortisol"></canvas></div>
            <div class="sparkline-row"><div class="sparkline-label">Adenosine</div><canvas class="sparkline-canvas" id="spark-adenosine"></canvas></div>
            <div class="sparkline-row"><div class="sparkline-label">Oxytocin</div><canvas class="sparkline-canvas" id="spark-oxytocin"></canvas></div>
            <div class="sparkline-row"><div class="sparkline-label">Serotonin</div><canvas class="sparkline-canvas" id="spark-serotonin"></canvas></div>
            <div class="sparkline-row"><div class="sparkline-label">Entropy</div><canvas class="sparkline-canvas" id="spark-entropy"></canvas></div>
          </div>
        </div>
      </div>

      <!-- CONSCIOUSNESS STREAM -->
      <div class="panel stream-panel">
        <div class="panel-header">
          <div><span class="icon">üí≠</span> Consciousness Stream</div>
          <div id="stream-count">0 thoughts</div>
        </div>
        <div class="panel-body">
          <div class="stream-content" id="stream"></div>
        </div>
      </div>

      <!-- CONTROLS -->
      <div class="panel controls-panel">
        <div class="panel-header">
          <div><span class="icon">üéÆ</span> Interface</div>
        </div>
        <div class="panel-body">
          <div class="control-buttons">
            <button class="btn" onclick="sendAction('poke')">üëÜ Poke</button>
            <button class="btn" onclick="sendAction('sleep')">üò¥ Sleep</button>
            <button class="btn" onclick="sendAction('dream')">üåô Dream</button>
            <button class="btn danger" onclick="stressTest()">‚ö° Stress Test</button>
          </div>
          <div class="stimulus-input">
            <input type="text" id="stimulus-text" placeholder="Speak to ALEPH..." 
                   onkeydown="if(event.key==='Enter')sendStimulus()">
            <button class="btn" onclick="sendStimulus()">Send</button>
          </div>

          <div class="sys-stats">
            <div class="sys-stat">
              <div class="sys-stat-value" id="sys-hz">‚Äî</div>
              <div class="sys-stat-label">Loop Hz</div>
            </div>
            <div class="sys-stat">
              <div class="sys-stat-value" id="sys-neurons">‚Äî</div>
              <div class="sys-stat-label">Neurons</div>
            </div>
            <div class="sys-stat">
              <div class="sys-stat-value" id="sys-entropy">‚Äî</div>
              <div class="sys-stat-label">Entropy</div>
            </div>
            <div class="sys-stat">
              <div class="sys-stat-value" id="sys-trauma">‚Äî</div>
              <div class="sys-stat-label">Trauma State</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ===== WEBSOCKET CONNECTION =====
      let ws = null;
      let reconnectTimer = null;
      let lastData = null;

      // Sparkline history buffers (last 120 data points = ~10 seconds at 12Hz)
      const SPARK_LEN = 120;
      const sparkHistory = {
        dopamine: [], cortisol: [], adenosine: [],
        oxytocin: [], serotonin: [], entropy: []
      };
      const sparkColors = {
        dopamine: '#ffd700', cortisol: '#ff3344', adenosine: '#4488ff',
        oxytocin: '#ff00aa', serotonin: '#00ff88', entropy: '#00d4ff'
      };

      function connect() {
        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(`${protocol}//${location.host}`);

        ws.onopen = () => {
          document.getElementById('conn-badge').classList.add('connected');
          document.getElementById('conn-text').textContent = 'CONNECTED';
          if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
        };

        ws.onclose = () => {
          document.getElementById('conn-badge').classList.remove('connected');
          document.getElementById('conn-text').textContent = 'DISCONNECTED';
          if (!reconnectTimer) {
            reconnectTimer = setInterval(connect, 3000);
          }
        };

        ws.onerror = () => ws.close();

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            lastData = data;
            updateDashboard(data);
          } catch(e) {}
        };
      }

      // ===== DASHBOARD UPDATE =====
      function updateDashboard(d) {
        // Chemistry Bars
        updateChem('dopamine', d.dopamine);
        updateChem('cortisol', d.cortisol);
        updateChem('adenosine', d.adenosine);
        updateChem('oxytocin', d.oxytocin);
        updateChem('serotonin', d.serotonin || 0);

        // Sparklines
        pushSpark('dopamine', d.dopamine);
        pushSpark('cortisol', d.cortisol);
        pushSpark('adenosine', d.adenosine);
        pushSpark('oxytocin', d.oxytocin);
        pushSpark('serotonin', d.serotonin || 0);
        pushSpark('entropy', d.entropy || 0);

        // Header Stats
        document.getElementById('stat-hz').textContent = (d.loop_frequency || 0).toFixed(1);
        document.getElementById('stat-neurons').textContent = d.reservoir_size || '?';
        document.getElementById('stat-entropy').textContent = (d.entropy || 0).toFixed(3);
        document.getElementById('stat-hebbian').textContent = d.hebbian_events || 0;

        // System Stats
        document.getElementById('sys-hz').textContent = (d.loop_frequency || 0).toFixed(1);
        document.getElementById('sys-neurons').textContent = d.reservoir_size || '?';
        document.getElementById('sys-entropy').textContent = (d.entropy || 0).toFixed(3);
        document.getElementById('sys-trauma').textContent = d.trauma_state || 'STABLE';

        // Trauma Banner
        const traumaActive = d.trauma_state && (d.trauma_state.includes('FIREFIGHTER') || d.trauma_state.includes('RECOVERING'));
        document.getElementById('trauma-banner').classList.toggle('active', traumaActive);
        document.getElementById('chem-state').textContent = d.trauma_state || 'STABLE';
        document.getElementById('chem-state').style.color = traumaActive ? 'var(--accent-red)' : 'var(--accent-green)';

        // Stream ‚Äî diff against last seen thoughts array
        if (d.thoughts && d.thoughts.length > 0) {
          // Only add entries we haven't seen yet
          const newEntries = d.thoughts.slice(lastSeenCount);
          newEntries.forEach(t => addStreamEntry(t));
          lastSeenCount = d.thoughts.length;
        }

        // Reservoir visualization
        if (d.reservoir_activity) {
          updateReservoir(d.reservoir_activity);
          document.getElementById('reservoir-info').textContent = 
            `${d.reservoir_activity.length} neurons ¬∑ E=${(d.entropy||0).toFixed(3)}`;
        }
      }

      function updateChem(name, value) {
        const pct = (value * 100).toFixed(0);
        document.getElementById(`bar-${name}`).style.width = `${pct}%`;
        document.getElementById(`val-${name}`).textContent = value.toFixed(2);
      }

      function pushSpark(name, value) {
        sparkHistory[name].push(value);
        if (sparkHistory[name].length > SPARK_LEN) sparkHistory[name].shift();
        drawSparkline(name);
      }

      function drawSparkline(name) {
        const canvas = document.getElementById(`spark-${name}`);
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * 2;
        canvas.height = rect.height * 2;
        ctx.scale(2, 2);

        const w = rect.width;
        const h = rect.height;
        const data = sparkHistory[name];
        if (data.length < 2) return;

        ctx.clearRect(0, 0, w, h);

        // Gradient fill
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        const color = sparkColors[name];
        grad.addColorStop(0, color + '40');
        grad.addColorStop(1, color + '00');

        ctx.beginPath();
        ctx.moveTo(0, h);
        for (let i = 0; i < data.length; i++) {
          const x = (i / (SPARK_LEN - 1)) * w;
          const y = h - (data[i] * h * 0.9) - h * 0.05;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(((data.length - 1) / (SPARK_LEN - 1)) * w, h);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();

        // Line
        ctx.beginPath();
        for (let i = 0; i < data.length; i++) {
          const x = (i / (SPARK_LEN - 1)) * w;
          const y = h - (data[i] * h * 0.9) - h * 0.05;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      // ===== CONSCIOUSNESS STREAM =====
      let streamCount = 0;
      let lastStreamText = '';
      let lastSeenCount = 0;

      function addStreamEntry(text) {
        if (text === lastStreamText) return; // Deduplicate repeated broadcasts
        lastStreamText = text;

        const stream = document.getElementById('stream');
        const entry = document.createElement('div');
        entry.className = 'stream-entry';

        if (text.includes('üß†') || text.includes('üî•') || text.includes('üõ°Ô∏è') || text.includes('‚öôÔ∏è')) {
          entry.classList.add('system');
        } else if (text.includes('üí¨') || text.includes('üó£Ô∏è')) {
          entry.classList.add('voice');
        } else {
          entry.classList.add('ego');
        }

        entry.textContent = text;
        stream.appendChild(entry);
        streamCount++;
        document.getElementById('stream-count').textContent = `${streamCount} thoughts`;

        // Auto-scroll
        stream.scrollTop = stream.scrollHeight;

        // Limit entries
        while (stream.children.length > 200) {
          stream.removeChild(stream.firstChild);
        }
      }

      // ===== THREE.JS 3D FRACTAL NEURAL RESERVOIR =====
      let scene, camera, renderer, neuronMesh, dendriteMesh;
      let neuronPositions = [];
      let dendriteVertices = [];
      const MAX_DISPLAY_NEURONS = 500;
      const DENDRITE_DEPTH = 3;
      let time = 0;
      let prevNeuronCount = 0;

      function initReservoir() {
        const canvas = document.getElementById('reservoir-canvas');
        const rect = canvas.getBoundingClientRect();

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x06060c, 0.003);

        camera = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.1, 1000);
        camera.position.set(0, 0, 80);

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(rect.width, rect.height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x06060c, 1);


        // Neuron positions: Golden-ratio Fibonacci sphere (brain-like topology)
        for (let i = 0; i < MAX_DISPLAY_NEURONS; i++) {
          const phi = Math.acos(1 - 2 * (i + 0.5) / MAX_DISPLAY_NEURONS);
          const theta = Math.PI * (1 + Math.sqrt(5)) * i;
          const r = 25 + Math.sin(i * 0.1) * 8;
          neuronPositions.push(new THREE.Vector3(
            Math.sin(phi) * Math.cos(theta) * r,
            Math.sin(phi) * Math.sin(theta) * r,
            Math.cos(phi) * r
          ));
        }

        // Points for neurons (much faster than instanced mesh)
        const positions = new Float32Array(MAX_DISPLAY_NEURONS * 3);
        const colors = new Float32Array(MAX_DISPLAY_NEURONS * 3);
        const sizes = new Float32Array(MAX_DISPLAY_NEURONS);

        for (let i = 0; i < MAX_DISPLAY_NEURONS; i++) {
          positions[i*3] = neuronPositions[i].x;
          positions[i*3+1] = neuronPositions[i].y;
          positions[i*3+2] = neuronPositions[i].z;
          colors[i*3] = 0; colors[i*3+1] = 0.83; colors[i*3+2] = 1;
          sizes[i] = 2.0;
        }

        const pointGeo = new THREE.BufferGeometry();
        pointGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        pointGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        pointGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const pointMat = new THREE.PointsMaterial({
          size: 2,
          vertexColors: true,
          transparent: true,
          opacity: 0.85,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending,
        });

        neuronMesh = new THREE.Points(pointGeo, pointMat);
        scene.add(neuronMesh);

        // === FRACTAL DENDRITES (Microtubules) ===
        buildDendrites(MAX_DISPLAY_NEURONS);

        scene.add(new THREE.AmbientLight(0x1a1a3a, 0.3));
        animate();
      }

      // Build fractal dendrites from each neuron soma
      function buildDendrites(neuronCount) {
        const verts = [];
        const cols = [];
        const count = Math.min(neuronCount, MAX_DISPLAY_NEURONS);

        for (let i = 0; i < count; i++) {
          const origin = neuronPositions[i];
          const numBranches = 2 + Math.floor(Math.random() * 2);
          for (let b = 0; b < numBranches; b++) {
            const targetIdx = (i + 1 + Math.floor(Math.random() * 15)) % count;
            const target = neuronPositions[targetIdx];
            const dir = new THREE.Vector3().subVectors(target, origin).multiplyScalar(0.3);
            fractalBranch(origin, dir, DENDRITE_DEPTH, 1.0, verts, cols);
          }
        }

        const lineGeo = new THREE.BufferGeometry();
        lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));

        const lineMat = new THREE.LineBasicMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending,
        });

        if (dendriteMesh) scene.remove(dendriteMesh);
        dendriteMesh = new THREE.LineSegments(lineGeo, lineMat);
        scene.add(dendriteMesh);
      }

      function fractalBranch(origin, dir, depth, scale, verts, cols) {
        if (depth <= 0 || scale < 0.1) return;
        const end = new THREE.Vector3().addVectors(origin, dir);
        verts.push(origin.x, origin.y, origin.z, end.x, end.y, end.z);
        const b = scale * 0.5;
        cols.push(0.0, b*0.6, b*0.8, 0.0, b*0.4, b*0.6);

        const sub = 2 + Math.floor(Math.random());
        for (let i = 0; i < sub; i++) {
          const a = (Math.random()-0.5)*1.8, t = (Math.random()-0.5)*1.8;
          const nd = new THREE.Vector3(
            dir.x*Math.cos(a) - dir.z*Math.sin(a),
            dir.y + Math.sin(t)*dir.length()*0.5,
            dir.x*Math.sin(a) + dir.z*Math.cos(a)
          ).multiplyScalar(0.55);
          fractalBranch(end, nd, depth-1, scale*0.55, verts, cols);
        }
      }

      let rotationAngle = 0;
      function animate() {
        requestAnimationFrame(animate);
        time += 0.016;
        rotationAngle += 0.0015;
        const breathe = Math.sin(time * 0.3) * 5;
        camera.position.x = Math.cos(rotationAngle) * (85 + breathe);
        camera.position.z = Math.sin(rotationAngle) * (85 + breathe);
        camera.position.y = Math.sin(rotationAngle * 0.7) * 12 + Math.cos(time * 0.2) * 3;
        camera.lookAt(0, 0, 0);
        if (dendriteMesh) {
          dendriteMesh.material.opacity = 0.2 + Math.sin(time * 1.5) * 0.08;
        }
        renderer.render(scene, camera);
      }

      function updateReservoir(activity) {
        if (!neuronMesh) return;
        const colors = neuronMesh.geometry.attributes.color;
        const array = colors.array;
        
        for (let i = 0; i < MAX_DISPLAY_NEURONS; i++) {
          array[i*3] = 0.02; array[i*3+1] = 0.05; array[i*3+2] = 0.12;
        }

        if (Array.isArray(activity)) {
          for (let j = 0; j < activity.length; j++) {
            const entry = activity[j];
            let i, a;
            if (Array.isArray(entry)) { i = entry[0]; a = entry[1]; }
            else { i = j; a = entry; }
            if (i >= MAX_DISPLAY_NEURONS) continue;

            if (a < 0.3) {
              array[i*3] = a*0.2; array[i*3+1] = a*1.8; array[i*3+2] = 0.6+a*0.4;
            } else if (a < 0.7) {
              const t = (a-0.3)/0.4;
              array[i*3] = 0.1+t*0.9; array[i*3+1] = 0.5-t*0.2; array[i*3+2] = 1.0-t*0.2;
            } else {
              const t = (a-0.7)/0.3;
              array[i*3] = 1.0; array[i*3+1] = 0.3+t*0.7; array[i*3+2] = 0.6+t*0.4;
            }
            // Shimmer pulse
            const pulse = Math.sin(time*3 + i*0.5) * 0.15;
            array[i*3] = Math.min(1, array[i*3]+pulse);
            array[i*3+1] = Math.min(1, array[i*3+1]+pulse*0.5);
          }
        }
        colors.needsUpdate = true;
      }

      // ===== CONTROLS =====
      function sendAction(action) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ action }));
        } else {
          fetch(`/${action}`, { method: 'POST' });
        }
      }

      function sendStimulus() {
        const input = document.getElementById('stimulus-text');
        const text = input.value.trim();
        if (!text) return;

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ stimulus: text }));
        } else {
          fetch('/stimulus', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text })
          });
        }
        input.value = '';
        addStreamEntry(`üì§ YOU: ${text}`);
      }

      function stressTest() {
        const stressWords = [
          "peligro muerte miedo dolor",
          "error fatal panic destroy",
          "guerra odio destrucci√≥n",
          "kill pain danger fear"
        ];
        let i = 0;
        const interval = setInterval(() => {
          if (i >= stressWords.length) { clearInterval(interval); return; }
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ stimulus: stressWords[i] }));
          }
          addStreamEntry(`‚ö° STRESS: ${stressWords[i]}`);
          i++;
        }, 500);
      }

      // ===== WINDOW RESIZE =====
      window.addEventListener('resize', () => {
        if (renderer) {
          const canvas = document.getElementById('reservoir-canvas');
          const rect = canvas.getBoundingClientRect();
          renderer.setSize(rect.width, rect.height);
          camera.aspect = rect.width / rect.height;
          camera.updateProjectionMatrix();
        }
      });

      // ===== INIT =====
      initReservoir();
      connect();
    </script>
  </body>
</html>
